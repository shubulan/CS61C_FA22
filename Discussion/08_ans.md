# Pipelining and Hazards

## Pre-Check

1.1 通过将 datapath 流水线化，每一条指令将会执行的更快，延迟减小，最终导致性能的提高。

False; 流水线提高了 throughput ，无法提高延迟

1.2 流水线化的CPU导致指令执行时的吞吐量更高。

True

1.3 通过添加额外的硬件，我们可以使 RegFile 拥有两条 读取端口，一条写端口。这个解决了两条指令同时读写同一个寄存器的问题。

False; 没有完全解决，例如：数据依赖问题，准确的说是读写同一个寄存器。可以stall一个周期，也可以double-pumping,也可以 forward

1.4 所有的 data hazards 都可以通过 forwarding 解决。

False; lw解决不了，某些时候可以通过指令重排解决。

1.5 由于 stall 显著的降低了性能，我们通常通常喜欢用撇的方式来解决 hazards 问题。即使硬件和复杂性的提高也在所不惜。在现代的流水线CPU中，是否存在用 stalling 来解决潜在 hazards 的现象？举个例子？

存在； 例如：forwarding不能完全解决问题、指令也无法重排的时候，例如lw指令。stall 无法完全解决。

## 2 流水线 寄存器

2.1 新寄存器的作用是什么？

将上一级流水线的输出进行排队；

2.2 PC 为什么需要 +4 两次？

因为要将pc的下一条指令地址存下来，此外，在流水线中间的某些阶段还需要pc原来的值(auipc)。所以使用新的add 4 硬件比较自然，否则需要两条线，一条传递 原 pc 一条传递 pc + 4

2.3 为什么 pc 在保存了多次

一次保存代表一次排队。流水线中的每一个阶段都代表一次排队，因此每次排队的数据都要保存下来。


## 3 性能分析

3.1 时钟周期最快可以使多少？回忆一下，上周的讨论中，走过整个关键路径的指令是`lw`

~~q时间是30，setup时间是20，最长的组合电路时间是250，加起来得到300 ps~~
这里算的是没有用流水线之前的单周期延迟。只要算最长的两个时钟之间的距离应该就行了，为什么加了那么多 900？。。

3.2 流水线后，最快的时钟周期是多少？

最长阶段的延迟是主存 250ps + 30 + 20 = 300 ps

3.3 流水线化后，CPU 加速了多少？为什么小于5倍？

~~4x，~~ 3x ，这个是需要算的，而不是估计。900/300 = 3;

1. 因为中间增加了排队寄存器，延缓了一个时钟周期，导致少了一倍。
2. 因为所有的延迟都被规整到最长的延迟300ps了

## 4 Hazards
回顾：

结构化Hazards: 永远可以用钱来解决的

  通常发生在两个指令需要同一个硬件资源时。当前的data-path没有结构化Hazards.
有两个导致结构化Hazards的原因：
1. Register File: 解码指令后，需要读取寄存器。WB阶段需要写入寄存器。如果寄存器文件只有一个接口时，就会发生。
   - 通过分离接口可以解决，但是无法解决读写同一个寄存器的问题
   - 为了解决读写同一个寄存器问题，可以在上升沿写，在下降沿读。double-pumping 的思想
2. Main Memory: 主存同时存储指令和数据。如果内存在同一时间只支持读或者写之一的操作，那么IF阶段的内存读和对内存数据的操作就会冲突。
   - 分离指令寄存器和数据寄存器就可以解决这个问题。

数据Hazards: 
  主要原因是指令之间的数据依赖。当一条指令读取一个之前的指令需要写但还没完全写入的寄存器
时会发生。主要有两种类型
* EX-ID: 执行阶段的输出直到写回阶段才能真正写入寄存器，但是却被接下来的指令在解码阶段获取。
* MEM-ID: 内存获取阶段的输出直到写回阶段才能真正写入寄存器，但是却被接下来的指令在解码阶段获取。
  
假设不考虑分支预测和double-pumping,解决办法
* Forwarding: 不将结果写回寄存器，而是直接写到需要的位置

4.1 forwarding 解决下面的data hazard.
链接两条箭头

4.2 
~~两条指令会被影响。后面的指令执行时，寄存器已经写回了。~~
三条指令被影响。被影响要看ID (指令解码阶段) 而不是 EX 指令执行阶段。
如果允许：double-pumping，那么就只有两条指令了。

Stall

4.3 
lw 需要mem操作，mem 操作在下一条指令的EX之后，无法forwarding。可能得操作要么是加入nop操作造成Stall，要么，使用指令重排，将第一条指令插入到3和4之间。

4.4 

4.3 说过了。

探测 Data Hazards

对于相邻的两条指令 n, n+1。如果n条指令的rd等于n+1条指令的rs1或者rs2并且该指令需要写回，那么就存在Data Hazards

Control Hazards

控制 Hazards 是由跳转指令造成的。

4.5 
除了Stall之外，还可以分支预测

4.6 针对以下指令流回答

有多少 hazards ? 3个

types: 
* 1->2 data hazards
* 2->3 data hazards
* 2 -> 4 data hazards
* 4 control hazards

~~如果使用double-pumping, 有多少 Stall ？ 4 个 没影响~~
如果使用double-pumping，只有两条指令会被影响。
1->2会被影响两个stall
2->3会被影响两个stall
2->4不会被影响，因为2-3的stall抹平了

如果使用分支预测，control hazards 会怎么样？ 循环会导致一次预测失败。

如果预测成功，没有 stall ，如果预测失败，需要清空流水线，三个stall(MEM->1 cycle before IF)