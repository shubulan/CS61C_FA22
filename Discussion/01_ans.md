# Number Representation
## 1. Pre-check
> 概念理解，判断题
### 1.1 根据不同的环境，相同的位序列，可能代表不同的东西. 
    True
### 1.2 在补码表示中，两个相反符号相加有可能溢出
    False
### 1.3 如果你把N位补码当做无符号数来解释，负数可能小于正数
    False
### 1.4 如果你把N位偏移计数法解释称无符号整数，负数将小于正数
    True
### 1.5 我们可以用给定的数字表示格式来表示分数和小数(无符号、有偏和二进制补码)。
    False
## 2. 无符号整数

### 2.1 2/10/16 进制之间转换

* a 进制间转换

  1. 0b10010011  -> dec: 147  hex: 0x93
  2. 63 -> bin: 0b0011 1111 hex: 0x3f
  3. 0b00100100 -> dec: 36 hex: 0x24
  4. 0 -> bin: 0b0 hex: 0x0
  5. 39 -> bin: 0b 0010 0111 hex: 0x27
  6. 437 -> bin: 0b 1 1011 0101 hex: 0x1b5
  7. 0x0123 -> bin: 0b 0000 0001 0010 0011 dec: 291
* b 16 转 2 进制
  
  1. 0xD3AD -> bin: 0b 1101 0011 1010 1101
  2. 0xB33F -> bin: 0b 1011 0011 0011 1111 
  3. 0x7EC4 -> bin: 0b 0111 1110 1100 0100

### 2.2 IEC 计数法

a: 转换成 IEC 前缀

$2^{16}=64Ki$

$2^{27}=128Mi$

$2^{43}=8Ti$

$2^{36}=64Gi$

$2^{34}=16Gi$

$2^{61}=2Ei$

$2^{47}=128Ti$

$2^{59}=512Pi$

b: 转换成 2 的幂

$2Ki = 2^{10}$

$512Ki = 2^{19}$

$16Mi = 2^{24}$

$256Pi = 2^{58}$

$64Gi = 2^{36}$

$128i = 2^{67}$

## 3. 有符号整数
### 3.1 

问题 a 到 c 均为 8 位整数。偏差数的偏差为 -127.

a: 最大的整数？如果其 +1 会得到什么结果？
1. 无符号： 255， + 1 为 0
2. 偏置编码： 128，+ 1 为 -127
3. 补码： 127，+ 1 为 -128

b: 如何表示 0 1 -1
1. 无符号： 0b 0000 0000, 0b 0000 0001 无法表示
2. 偏置编码： 0b 0111 1111, 0b 1000 0000, 0b 0111 1110
3. 补码： 0b 0000 0000, 0b 0000 0001, 0b 1111 1111 

c: 如何表示 17 -17 ？
1. 无符号：0b 0001 0001 无法表示
2. 偏置编码： 0b 1001 0000, 0b 0110 1110
3. 补码： 0b 0001 0001, 0b 1110 1111

### 3.2 证明补码转换技巧是正确
先列出几个前提：
1. 补码分为符号位和有效位，如果将数字0看做正数的话，可以通过符号位来将数字分为两组：正数和负数。
2. 加法使用无符号的加法

以 8 位补码为例，其范围为 [-128, 127], 将其分为三类来讨论： -128， 0， 其他数字。
1. -128 表示为 0b 1000 0000，按照该技巧转换后，仍是 
   > 0b 1000 0000 = 0b 0111 1111 + 1
2. 0 表示为 0b 0000 0000，转换后仍是 0b0
     > 0b 0000 0000 = 0b 1111 1111  + 1
3. 其他数字
   1. 对于正数 a ，按照one's complement 到 two's complement的理解，可以证明是正确的：(~a)是 one's complement的负数，去掉 -0 的位置，two's complement -a = (~a) + 1；对于负数
   2. 对于负数 a ，将上述过程逆向，对应的 -a (正数) 应为 ~(a - 1)。可以证明：
        ~(a - 1) = (~a) + 1 

### 3.3 现在已经学习了三种主要的进制， 2/10/16 进制，我们为什么用这三个进制以及我们为什么更喜欢这三个进制
2进制是因为晶体管更容易实现，10进制是因为我们现实中常用，16进制是因为使人类读取2进制更容易

## 4. 算数与计算

### 4.1 加减法
a: 计算以下算式的10进制结果，它们是6位补码。它们有溢出么？这些计算式正确么？
1. 0b 01 1001 − 0b 00 0111 = 25 - 7 = 18，无溢出，正确
2. 0x3B + 0x06 = 0x35 = 53 无溢出，正确
3. 0xFF − 0xAA = 0x55 = 85 无溢出，正确
4. 0b000100 − 0b001000 = 0b000100 + 0b111000 = 0b111100 = 56 无溢出，正确

b: 以下数值范围，最少需要多少位来表示？
1. 0 ~ 256 ： 补码： 10 位， 偏置码 9 位 无符号： 9 位
2. -7 ~ 56 ： 补码： 8 位， 偏置码 6 位 无符号： 无法表示
3. 64 ~ 127 ： 补码： 8 位， 偏置码 6 位 无符号： 7 位
4. -127 ~ -64 ： 补码： 8 位， 偏置码 8 位 无符号： 无法表示
5. 12 TiB内存 ： 补码： 45 位， 偏置码 44 位 无符号： 44 位

c: 以下表示最多可以表示多少数字？正数呢？

这里没有算0
1. 10 位无符号 [0, 2^10 - 1] 2^10个不同的数字，正数有2^10 - 2 个
2. 8 位补码 [-2^7, 2^7 - 1] 2^8个不同的数字， 正数有 2^7 - 2 个
3. 8 位 one's complement [-(2^7 - 1), 2^7 - 1] 2^8 - 1个不同的数字，正数有 2^7 - 2 个
4. 6 位偏置码，bias 为 -30 : [-30, 33] 2^6 个不同的数字，正数有 32 个
5. 10 位 sign-magnitude 编码： [-(2^9 - 1), 2^9 - 1] 2^10 - 1个不同的数字，正数有 2^9 - 2个