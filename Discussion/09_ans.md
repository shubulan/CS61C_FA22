# 09 缓存

## 1. precheck

1.1 无法在 32-bit 系统上使用 1KB 缓存，因为它太小了，无法包含所有地址。

错，缓存本来就是小的。通过组相连、全相连等方式来索引最近的内存地址

1.2 如果数据在缓存和主存中都有，那么缓存更快 对

1.3 在程序执行时，缓存在获取内存数据上有一个立即的提升。

错。首先会有一个缓存未命中。然后才会利用局部性加速

1.4 发生在缓存满了的时候的缓存不命中是 capacity miss。 对

1.5 通过增加更多 blocks 来增加缓存大小总是能够对所有的程序提升命中率

错。万一程序只用了一块缓存呢？ 总体来说应该确实能提高命中率。

1.6 减少 block size 增加 block 的数量能够提高所有程序的速度。

错。减少 block size 会增加首次 miss 的概率，不一定能提高执行速度

## 2. Hazards Review: CPI
假设 5 阶段 流水线，没有优化，分支预测永远是对的

2.1 相邻指令的 data hazard 有几个？ control hazard 造成的 penalty cycles 有几个？

* 2 4 两行也有 不过不影响，因为 3 4 两行stall过了（data hazard 会影响三行）
* 3 4 两行也有 data hazard
* 5 6 两行的 t2 有数据依赖
* 6 7 两行的 t2 有数据依赖
* 7 8 两行的 t2 有数据依赖
* 11 12 两行的 t2 有数据依赖
每个数据依赖都有 3 个 stall

* 4 行 bge 只有 1 次 错误
* 10 行 jal 10 次都是错的

~~jal 会使 4 条指令失效~~ 下一条指令只需要在跳转指令的 mem 之后 即可，不需要 wb 之后，所以也是 3 个

2.2 
* 1  ~ 3  一遍
* 4  ~ 10 10 遍 + 1 个指令
* 11 ~ 14  一遍

共计 3 + 4 + 7 x 10 + 1 = 78 个指令

2.3 忽略填将流水线填满的周期，执行程序总共花费了多少指令周期？
通常一个周期，一个指令，但是 ~~4~~ 3 个 data hazard 浪费了 ~~4~~ 3 x 3 个周期； <忘记算的 9->4 有 2 个 stall>4~10 行代码要执行 10 遍所以浪费了 ~~12~~ (3 x 3 + 2) x 10 = 110 个周期

~~jal 也执行了 10 遍 浪费了 40 个周期，所以总周期是~~ jal 的 hazard 不算
bge 只错了一次，浪费 ~~4~~ 3 个周期
<此外，忘记算的：3->4 3 个周期, 11->12 有 3 个周期>
~~78 + 120 + 40 + 4 = 242 个周期~~
78 + 110 + 3 + 3 + 3 = 197 个周期

2.4 基于前两个部分，我们的 cpu 的 CPI 是多少？
(197 + 4(填充流水线)) / 78 = 2.58

## 3. 理解 T/I/O

3.1 3 4 两位用于索引

3.2 5~31 位用于tag, offset 是 0 1 2 三位

3.3

|地址              |T/I/O/    | Hit Miss Replace|
|---              |---       |---|
|0x04 -> 0000 0100|000/00/100|Mis| compulsory
|0x05 -> 0000 0101|000/00/101|Hit| 
|0x68 -> 0110 1000|011/01/000|Mis| compulsory
|0xC8 -> 1100 1000|110/01/000|Rep| conflict
|0x68 -> 0110 1000|011/01/000|Rep| ~~conflict~~ capacity
|0xDD -> 1101 1101|110/11/101|Mis| compulsory
|0x45 -> 0100 0101|101/00/101|Rep| ~~conflict~~ compulsory
|0x04 -> 0000 0100|000/00/100|Rep| ~~conflict~~ capacity
|0xC8 -> 1100 1000|110/01/000|Rep| ~~conflict~~ capacity
 
 
 ## 4 缓存未命中的分类
 命中的分类要从字节上考虑

1. Compulsory: 缓存冷启动时的必然 Miss。第一次访问某个字节才会造成该不命中，但也有可能命中了，因为空间局部性
2. Conflict: 访问某一字节时，应该存放该地址内容的缓存行的对应 offset，因为其他的直接访问而存了其他东西就是冲突
3. Capacity: 访问某一字节时，应该存放该地址内容的缓存行存了其他东西，但不是comflict，就是Capacity


## 5 代码分析
分析 命中率， 16KB 直接映射缓存 1KB blocks

5.1 内存地址多少位？

1MB 内存 20 位地址

5.2 TIO

tag: 6 位
Idx: 4 位
offset: 10 位

5.3 计算 line1 的缓存命中率

64 次访问有一半会未命中，50%

5.4 计算 line2 的缓存命中率

同样 64 次访问 但是第一遍访问的后半部分把前半部分覆盖了，所以跟第一次一样 50%