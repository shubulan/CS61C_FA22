# Discussion 10 缓存性能

## 1 pre check

1.1 在 write-back 缓存中，写操作通常比 write-through 缓存慢。

错，write-back 要比 write-through 要快一点

1.2 在全关联缓存中，索引位总是 0 . 对

1.3 同样的缓存大小 和 block size， 4-way 关联 有较少的索引位 比起直接映射。 对

1.4 使用 N-way 关联缓冲 可以帮助平衡硬件的复杂性和缓存的性能 对

1.5 增加缓存大小对于全关联，LRU 替换策略缓存的 miss 率没有提升。 对
  对于LRU 算法，增加缓存大小对命中率优化是正的。但是如果 FIFO 性质的算法，是有可能存在增加缓存大小，而增加了更多 miss 的情况，叫做 belady 异常。操作系统中会讲。

1.6 增加另一个层次的缓存不会提升 AMAT(平均数据获取时间) 错

1.7 最后一级缓存的 miss penalty 和 主存的获取时间是相等的。 
  对的。可能有细微差别，但应该视作是相等的

## 2 缓存关联性

2.1 2-way 组相联缓存。8 位地址，8B block 大小，32B 缓存大小，填写下面表格。如果是 miss，增加 miss 种类
| **adreess** | **T/I/O**  | **Hit,Miss,Replace** | **miss type** |
|-------------|------------|----------------------|---------------|
| 0b0000 0100 | 0000/0/100 | Miss                 | Comp          |
| 0b0000 0101 | 0000/0/101 | Hit                  |               |
| 0b0110 1000 | 0110/1/000 | Miss                 | Comp          |
| 0b1100 1000 | 1100/1/000 | Miss                 | Comp          |
| 0b0110 1000 | 0110/1/000 | Hit                  |               |
| 0b1101 1101 | 1101/1/101 | Miss                 | Comp          |
| 0b0100 0101 | 0100/0/101 | Miss                 | Comp          |
| 0b0000 0100 | 0000/0/100 | Hit                  |               |
| 0b1100 1000 | 1100/1/000 | Miss                 | Capacity      |


2.2  命中率 33%

# 3 写缓存

3.1 考虑a direct mapped, no write-allocate, write-through cache with a capacity of 8B and a block size of 4B, 缓存操作序列如下，

我们将访问主存多少次？
* 0x6A, Write ： 一次，一次更新内存
* 0x85, Read ： 一次，从内存获取
* 0x6B, Read ： 一次，从内存获取 
* 0x87, Read ：hit
* 0x68, Write : 一次，更新内存
总共 4 次

3.2 与 3.1 一样的情况，把 write 策略改为 no write-allocate 和 write-back, 会怎样

* 0x6A, Write ： 一次，更新内存
* 0x85, Read ： 一次，从内存获取
* 0x6B, Read ： 一次，从内存获取
* 0x87, Read ：hit
* 0x68, Write : 更新缓存
总共 3 次

3.3 最后优化，使用 write-allocate 缓存策略 和 write-back
* 0x6A, Write ： 一次，一次从内存获取，一次更新缓存
* 0x85, Read ： 一次，从内存获取
* 0x6B, Read ： hit
* 0x87, Read ：hit
* 0x68, Write : 更新缓存

总共两次

3.4 前面三道题发现有一个策略是最好的。这个策略是最优化策略么？如果是的话，为什么？如果不是的话，平衡点是什么？
不是最优化策略。通过分析可将读写内存分成如下情况
| **读写\内存** | **内存局部性好** | **局部性不好** |
|-----------|------------|-----------|
| 写多        | 写分配、写回     | 写分配、写回    |
| 读多        | 写分配、写回     | 不分配、写回    |
发现只有局部性不好的时候，并且读取比较多时，采用 不分配、写回 的策略比较好。其他情况下，都是写分配，写回。

答案是：写分配、写回用的最多。但是有部分 cpu 用的是 写穿。因为写回会造成缓存和主存的内存不一致，在多核 cpu 的设计上是一个挑战。

## 4 AMAT

4.1 20 / 100 = 20 %

4.2 20 / (100 - 50) = 40 %

4.3 25 %

4.4 

AMAT = L1 hit time + L1 局部miss率 x (L2 hit time + L2 局部miss率)
     = 2 + 0.2 x (15 + 0.25 x 100) = 10

4.5 

2 + 0.2 x (15 + 0.25 x (x + 0.3 x 100)) <= 8

x < 30